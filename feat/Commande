### Fiche commandes — tests & jobs internes (local)

Prérequis:
- Docker (Supabase local)
- Node + npm
- Deno (pour les tests Deno dans `supabase/functions/**/*_test.ts`, inclut les tests “tools agents”)
- (Optionnel E2E) Playwright browsers (voir plus bas)

---

### Test ultime (A→Z) — 1 commande

#### SMOKE (rapide, fiable, sans dépendre de Gemini)
Start Supabase + reset DB + tests Deno + tests Vitest d’intégration (inclut flows “UI” DB + triggers DB non-edge).

```bash
npm run test:mega
```

#### FULL (inclut triggers/cron → Edge Functions → effets DB comme `memories`, `user_core_identity`, archive)
```bash
npm run test:mega -- --full
```

#### FULL + IA réelle (Gemini + embeddings)
⚠️ plus lent + dépend du réseau/quotas/coût. Nécessite `GEMINI_API_KEY` configurée dans les secrets Edge.

```bash
npm run test:mega -- --full --ai
```

#### Options utiles
```bash
# ne reset pas la DB
npm run test:mega -- --no-reset

# isoler une partie
npm run test:mega -- --skip-deno
npm run test:mega -- --skip-frontend

# inclure les tests E2E UI (Playwright)
npm run test:mega -- --full --no-reset --e2e
```

---

### Lancer une partie seulement

#### Vitest (tests d’intégration frontend)
```bash
cd frontend
npm run test:int
```

#### Vitest (sécurité / RLS) — tests “négatifs” (doivent échouer côté DB)
Inclus dans `npm run test:int` et donc dans `test:mega`, mais tu peux les cibler :

```bash
cd frontend
npx vitest run src/security/rls-negative.int.test.ts
```

#### Deno (tests unitaires des helpers Edge)
```bash
cd supabase/functions
deno test -A --no-lock
```

#### Playwright (tests E2E UI: clics réels)

1) Installer les browsers (une fois) :

```bash
cd frontend
npm run test:e2e:install
```

2) Lancer les E2E :

```bash
cd frontend
npm run test:e2e
```

#### Playwright (stress / volume) — Chat
Ce test est inclus dans `npm run test:e2e` :

```bash
cd frontend
npx playwright test e2e/stress-chat.e2e.spec.ts
```

Astuce (recommandé) : lancer via le mega-test pour avoir les variables d’env automatiquement :

```bash
npm run test:mega -- --full --no-reset --e2e
```

#### Supabase local
```bash
npm run db:start
npm run db:reset
npm run db:stop
```

---

### Jobs internes (cron) — reset / sync / trigger manuel

#### Après un `db reset`, est-ce qu’il faut refaire les crons ?
Oui. Un reset remet la DB à zéro → les jobs `pg_cron` disparaissent.

#### Reset “safe” (ne pousse aucun secret)
```bash
./scripts/local_reset.sh
```

#### (Optionnel) Si tu utilises des jobs internes en local
Si tu as des 403 sur des Edge Functions “internes” (jobs/cron), synchronise le secret **uniquement en local** (Vault) :

```bash
./scripts/local_sync_internal_secret.sh
```

Puis tu peux déclencher un job manuellement :

```bash
./scripts/local_trigger_internal_job.sh detect-future-events
./scripts/local_trigger_internal_job.sh process-checkins
./scripts/local_trigger_internal_job.sh trigger-memory-echo
```

---

### (Legacy) Déclencher une fonction interne via curl + secret récupéré depuis Vault



















0) Récupérer le secret (sans l’afficher) + helper

```bash
SECRET="$(docker exec -i supabase_db_Sophia_2 psql -U postgres -d postgres -tA -c \
"select decrypted_secret from vault.decrypted_secrets where name='INTERNAL_FUNCTION_SECRET' limit 1;")"
```

1) Déclencher `detect-future-events`

```bash
curl -s -X POST "http://127.0.0.1:54321/functions/v1/detect-future-events" \
  -H "Content-Type: application/json" \
  -H "X-Internal-Secret: $SECRET" \
  -d '{}' | cat
```

2) Déclencher `process-checkins`

```bash
curl -s -X POST "http://127.0.0.1:54321/functions/v1/process-checkins" \
  -H "Content-Type: application/json" \
  -H "X-Internal-Secret: $SECRET" \
  -d '{}' | cat
```

3) (optionnel) Déclencher `trigger-memory-echo`

```bash
curl -s -X POST "http://127.0.0.1:54321/functions/v1/trigger-memory-echo" \
  -H "Content-Type: application/json" \
  -H "X-Internal-Secret: $SECRET" \
  -d '{}' | cat


4) Déclencher "Trigger daily bilan"
curl -s -X POST "http://127.0.0.1:54321/functions/v1/trigger-daily-bilan" \
  -H "Content-Type: application/json" \
  -H "X-Internal-Secret: $SECRET" \
  -d '{}' | cat
```

<<<<<<< HEAD
=======

>>>>>>> staging
SUPABASE POUR SELECT le bon projet : 
Avec la CLI (pour éviter une boulette)
1) Liste les projets :
list
supabase projects list
2) Link explicitement :
iabxchanerdkczbxyjgg
supabase link --project-ref iabxchanerdkczbxyjgg
3) Vérifie le ref enregistré localement :
ref
cat supabase/.temp/project-ref
Si ce fichier affiche iabxchanerdkczbxyjgg, tu es sur le bon projet.



GIT pour selectionner le bon projet : 
git status
git branch

<<<<<<< HEAD
Pour se mettre sur le bon projet : 
git checkout main (ou staging ) ou git switch main
git switch staging
git checkout main
git merge staging
git push origin main

=======
>>>>>>> staging
Pour pousser (vers staging): 
    git add .
    git commit -m " "
    git push origin staging




SUPPRIMER TOUS LES SECRETS DE LA BD : 
for k in $(supabase secrets list | awk 'NR>1 && $1!="NAME"{print $1}'); do
  supabase secrets unset "$k"
done


Script “supprimer partout où user_id = ce user” (cloud Supabase)
À coller dans Supabase Dashboard → SQL Editor (⚠️ irréversible) :
1) Récupère l’UUID :
select id, email
from auth.users
where email = 'EMAIL_DE_L_USER';

2) Purge toutes les lignes qui ont une colonne user_id + suppression du user :


do $$
declare
  uid uuid := 'UUID';
  r record;
begin
  -- 1) supprimer l'utilisateur auth (déclenche les cascades)
  delete from auth.users where id = uid;

  -- 2) nettoyer toutes les tables public qui ont une colonne uid (user_id / profile_id / id)
  for r in
    select table_schema, table_name, column_name
    from information_schema.columns
    where table_schema = 'public'
      and udt_name = 'uuid'
      and column_name in ('user_id', 'profile_id', 'id')
  loop
    execute format('delete from %I.%I where %I = %L', r.table_schema, r.table_name, r.column_name, uid);
  end loop;
end
$$;


  -- 2) profiles: la colonne s'appelle id (pas user_id)
  delete from public.profiles where id = uid;

  -- 3) supprime le user auth (nettoie le reste via FK / cascade / set null côté auth)
  delete from auth.users where id = uid;
end $$;

commit;




Pour lancer supabase avec le .env : 
npx supabase functions serve --env-file supabase/.env



Trigger le bilan : 
./scripts/local_trigger_internal_job.sh trigger-daily-bilan




COMMMANDE POUR TOUT OUVRIR POUR UN UTILISATEUR : 


begin;

with
  params as (
    select '__USER_ID__'::uuid as uid
  ),

  -- 1) Semaines + portes d’entrée Forge/Table Ronde
  weeks as (
    select generate_series(1, 12) as w
  ),
  week_state_ids as (
    select format('week_%s', w) as module_id from weeks
    union all select 'forge_access'
    union all select 'round_table_1'   -- uniquement celle-ci
  ),
  upsert_week_states as (
    insert into public.user_week_states (user_id, module_id, status, available_at, completed_at)
    select p.uid, ids.module_id, 'available', now(), null
    from params p
    cross join week_state_ids ids
    on conflict (user_id, module_id) do update
      set
        status = case when public.user_week_states.status = 'completed' then 'completed' else 'available' end,
        available_at = least(public.user_week_states.available_at, excluded.available_at),
        completed_at = case when public.user_week_states.status = 'completed' then public.user_week_states.completed_at else null end,
        updated_at = now()
    returning 1
  ),

  -- 2) Forge: débloquer tous les modules aX_cY_m{2..5} (toutes semaines, toutes cartes)
  cards as (
    select
      w,
      generate_series(1, case when w = 1 then 4 else 3 end) as c
    from weeks
  ),
  levels as (
    select generate_series(2, 5) as m  -- niveaux 2 à 5 uniquement
  ),
  forge_ids as (
    select format('a%s_c%s_m%s', cards.w, cards.c, levels.m) as module_id
    from cards
    cross join levels
  ),
  upsert_forge_entries as (
    insert into public.user_module_state_entries (user_id, module_id, status, available_at, completed_at, content)
    select p.uid, f.module_id, 'available', now(), null, '{}'::jsonb
    from params p
    cross join forge_ids f
    on conflict (user_id, module_id) do update
      set
        status = case when public.user_module_state_entries.status = 'completed' then 'completed' else 'available' end,
        available_at = least(public.user_module_state_entries.available_at, excluded.available_at),
        completed_at = case when public.user_module_state_entries.status = 'completed' then public.user_module_state_entries.completed_at else null end,
        updated_at = now()
    returning 1
  )

select
  (select count(*) from upsert_week_states)   as week_states_touched,
  (select count(*) from upsert_forge_entries) as forge_modules_touched;

commit;




Lancer la fonction trigger memory echo : 

curl -s -X POST "http://127.0.0.1:54321/functions/v1/trigger-memory-echo" \
  -H "Content-Type: application/json" \
  -H "X-Internal-Secret: sophia-_on_earth" \
  -d '{"email":"thomasgenty30@gmail.com","force":true,"debug":true}'


  Pour lancer bilan spécifique : 
  cd "/Users/ahmedamara/Dev/Sophia 2/frontend"
node scripts/run_ui_bilan_eval_bundle.mjs \
  --turns 15 \
  --bilan-actions 3 \
  --difficulty mid \
  --model gemini-2.5-flash \
  --timeout-ms 600000 \
  --post-bilan

  Poour lanceer test onboarding whatsapp : 
  cd "/Users/ahmedamara/Dev/Sophia 2/frontend"
npm run eval:wa:onboarding:bundle -- --tests 10 --seed 123 --turns 8 --model gemini-2.5-flash --timeout-ms 600000


Pour lancer test pour les tools : 
npm run eval:tools -- --scenario tools_create_action


Chargé bon environnement : 

cd "/Users/ahmedamara/Dev/Sophia 2" && supabase functions serve --env-file supabase/.env