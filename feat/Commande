### Fiche commandes — tests & jobs internes (local)

Prérequis:
- Docker (Supabase local)
- Node + npm
- Deno (pour les tests Deno dans `supabase/functions/**/*_test.ts`, inclut les tests “tools agents”)
- (Optionnel E2E) Playwright browsers (voir plus bas)

---

### Test ultime (A→Z) — 1 commande

#### SMOKE (rapide, fiable, sans dépendre de Gemini)
Start Supabase + reset DB + tests Deno + tests Vitest d’intégration (inclut flows “UI” DB + triggers DB non-edge).

```bash
npm run test:mega
```

#### FULL (inclut triggers/cron → Edge Functions → effets DB comme `memories`, `user_core_identity`, archive)
```bash
npm run test:mega -- --full
```

#### FULL + IA réelle (Gemini + embeddings)
⚠️ plus lent + dépend du réseau/quotas/coût. Nécessite `GEMINI_API_KEY` configurée dans les secrets Edge.

```bash
npm run test:mega -- --full --ai
```

#### Options utiles
```bash
# ne reset pas la DB
npm run test:mega -- --no-reset

# isoler une partie
npm run test:mega -- --skip-deno
npm run test:mega -- --skip-frontend

# inclure les tests E2E UI (Playwright)
npm run test:mega -- --full --no-reset --e2e
```

---

### Lancer une partie seulement

#### Vitest (tests d’intégration frontend)
```bash
cd frontend
npm run test:int
```

#### Vitest (sécurité / RLS) — tests “négatifs” (doivent échouer côté DB)
Inclus dans `npm run test:int` et donc dans `test:mega`, mais tu peux les cibler :

```bash
cd frontend
npx vitest run src/security/rls-negative.int.test.ts
```

#### Deno (tests unitaires des helpers Edge)
```bash
cd supabase/functions
deno test -A --no-lock
```

#### Playwright (tests E2E UI: clics réels)

1) Installer les browsers (une fois) :

```bash
cd frontend
npm run test:e2e:install
```

2) Lancer les E2E :

```bash
cd frontend
npm run test:e2e
```

#### Playwright (stress / volume) — Chat
Ce test est inclus dans `npm run test:e2e` :

```bash
cd frontend
npx playwright test e2e/stress-chat.e2e.spec.ts
```

Astuce (recommandé) : lancer via le mega-test pour avoir les variables d’env automatiquement :

```bash
npm run test:mega -- --full --no-reset --e2e
```

#### Supabase local
```bash
npm run db:start
npm run db:reset
npm run db:stop
```

---

### Jobs internes (cron) — reset / sync / trigger manuel

#### Après un `db reset`, est-ce qu’il faut refaire les crons ?
Oui. Un reset remet la DB à zéro → les jobs `pg_cron` disparaissent.

#### Workflow simple
```bash
./scripts/local_reset.sh
```

#### Re-synchroniser le secret interne (Vault ↔ Edge Runtime)
```bash
./scripts/local_sync_internal_secret.sh
```

#### Déclencher les jobs “à la main” (sans cron)
```bash
./scripts/local_trigger_internal_job.sh detect-future-events
./scripts/local_trigger_internal_job.sh process-checkins
./scripts/local_trigger_internal_job.sh trigger-memory-echo
```

---

### (Legacy) Déclencher une fonction interne via curl + secret récupéré depuis Vault



















0) Récupérer le secret (sans l’afficher) + helper

```bash
SECRET="$(docker exec -i supabase_db_Sophia_2 psql -U postgres -d postgres -tA -c \
"select decrypted_secret from vault.decrypted_secrets where name='INTERNAL_FUNCTION_SECRET' limit 1;")"
```

1) Déclencher `detect-future-events`

```bash
curl -s -X POST "http://127.0.0.1:54321/functions/v1/detect-future-events" \
  -H "Content-Type: application/json" \
  -H "X-Internal-Secret: $SECRET" \
  -d '{}' | cat
```

2) Déclencher `process-checkins`

```bash
curl -s -X POST "http://127.0.0.1:54321/functions/v1/process-checkins" \
  -H "Content-Type: application/json" \
  -H "X-Internal-Secret: $SECRET" \
  -d '{}' | cat
```

3) (optionnel) Déclencher `trigger-memory-echo`

```bash
curl -s -X POST "http://127.0.0.1:54321/functions/v1/trigger-memory-echo" \
  -H "Content-Type: application/json" \
  -H "X-Internal-Secret: $SECRET" \
  -d '{}' | cat
```


SUPABASE POUR SELECT le bon projet : 
Avec la CLI (pour éviter une boulette)
1) Liste les projets :
list
supabase projects list
2) Link explicitement :
iabxchanerdkczbxyjgg
supabase link --project-ref iabxchanerdkczbxyjgg
3) Vérifie le ref enregistré localement :
ref
cat supabase/.temp/project-ref
Si ce fichier affiche iabxchanerdkczbxyjgg, tu es sur le bon projet.



GIT pour selectionner le bon projet : 



Commande pour créer le master admin : 
do $$
declare
  master_email text := 'thomasgenty15@gmail.com';
  -- Mets un mot de passe temporaire ici (tu pourras le changer ensuite via “Mot de passe oublié”).
  master_password text := '123456';
  master_id uuid;
  inst_id uuid;
begin
  -- Si l'utilisateur existe déjà, on récupère son id.
  select id into master_id
  from auth.users
  where lower(email) = lower(master_email)
  limit 1;

  if master_id is null then
    -- Récupère un instance_id (selon version GoTrue/Supabase Auth)
    if to_regclass('auth.instances') is not null then
      select id into inst_id from auth.instances limit 1;
    end if;

    if inst_id is null then
      inst_id := '00000000-0000-0000-0000-000000000000'::uuid;
    end if;

    master_id := gen_random_uuid();

    insert into auth.users (
      id,
      instance_id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      confirmation_token,
      recovery_token,
      email_change_token_new,
      email_change,
      email_change_token_current,
      reauthentication_token,
      raw_app_meta_data,
      raw_user_meta_data,
      created_at,
      updated_at
    ) values (
      master_id,
      inst_id,
      'authenticated',
      'authenticated',
      master_email,
      crypt(master_password, gen_salt('bf', 10)),
      now(),
      '',
      '',
      '',
      '',
      '',
      '',
      '{"provider":"email","providers":["email"]}'::jsonb,
      jsonb_build_object('full_name','Master Admin','phone','+33600000000'),
      now(),
      now()
    );

    -- Certaines versions nécessitent confirmed_at (en plus de email_confirmed_at)
    if exists (
      select 1
      from information_schema.columns
      where table_schema = 'auth' and table_name = 'users' and column_name = 'confirmed_at'
    ) then
      execute 'update auth.users set confirmed_at = default where id = $1 and confirmed_at is null'
      using master_id;
    end if;

    -- Best effort: phone_confirmed_at si la colonne existe
    if exists (
      select 1
      from information_schema.columns
      where table_schema = 'auth' and table_name = 'users' and column_name = 'phone_confirmed_at'
    ) then
      execute 'update auth.users set phone_confirmed_at = now() where id = $1 and phone_confirmed_at is null'
      using master_id;
    end if;

    -- Crée une identity email si la table existe
    if to_regclass('auth.identities') is not null then
      insert into auth.identities (
        id,
        user_id,
        provider,
        provider_id,
        identity_data,
        created_at,
        updated_at
      ) values (
        gen_random_uuid(),
        master_id,
        'email',
        master_email,
        jsonb_build_object('sub', master_id::text, 'email', master_email, 'provider', 'email'),
        now(),
        now()
      )
      on conflict do nothing;
    end if;
  end if;

  -- Normalise/force quelques champs (idempotent)
  update auth.users
  set
    instance_id = coalesce(instance_id, '00000000-0000-0000-0000-000000000000'::uuid),
    encrypted_password = crypt(master_password, gen_salt('bf', 10)),
    email_confirmed_at = coalesce(email_confirmed_at, now()),
    confirmation_token = coalesce(confirmation_token, ''),
    recovery_token = coalesce(recovery_token, ''),
    email_change_token_new = coalesce(email_change_token_new, ''),
    email_change = coalesce(email_change, ''),
    email_change_token_current = coalesce(email_change_token_current, ''),
    reauthentication_token = coalesce(reauthentication_token, ''),
    is_sso_user = false,
    is_anonymous = false,
    updated_at = now()
  where id = master_id;

  -- Profile (si ta table a plus de colonnes, adapte si besoin)
  insert into public.profiles (id, full_name, onboarding_completed)
  values (master_id, 'Master Admin', true)
  on conflict (id) do update set
    full_name = excluded.full_name,
    onboarding_completed = excluded.onboarding_completed,
    updated_at = now();

  -- Singleton admin (le trigger supprime/interdit les autres)
  delete from public.internal_admins where user_id <> master_id;

  insert into public.internal_admins (user_id)
  values (master_id)
  on conflict (user_id) do nothing;
end $$;